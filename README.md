# jounral entry 3
## subheading


Memory Management: 

Memory partitioning usually means dividing into sections like Poland during the 18th century. This partitioning allows for multiprogramming and multitasking by operating systems.   OS can also implement either fixed or variable partitions.  Fixed partitions is when the physical memory is split into partitions to which the process may be assigned. Variable partitioning is a solution to the fixed fragmentation problem found in fixed partitions by allowing for the partition size to be changed after creation. 

Virtual memory is a technique that gives the application program the impression that it has contiguous working memory. But in reality the application many be physically fragmented and could possibly overflow  the disk storage. This makes the programming of large applications easier and allows us to use RAM more efficiently.   

IN paging the physical memory is divided into equal sizes frames while the program is divided into equal size pages.  The frames are also designed to be the same size allowing for easy integration.  WHen a program is executed its pages loaded onto available memory and the page table is translated from users pages to memory frames.  IF the program needs more memory then what is available the only part of the memory only a part of it loaded.  IF the program evers tries to access pages that are not currently mapped onto RAM a page fault occurs.  THe solution to the problem is that the OS takes control and handles the problem in a manner invisible to the program. 
.
Memory Management requirements:

Relocation is when programs that are not loaded into a fixed point in memory  reside in various areas.

Protection means that each process should be protected against unwanted interference by   other
processes either accidentally or intentionally. And all memory references that are generated by a process must be checked at a specific time  to ensure that they only reference memory
 that has been assigned  to that process. 

Sharing is when the Protection mechanisms are flexible enough to allow a number of
processes to access the same area of memory.

Contiguous Organization is when programs are organized into sequential modules. However some of the 
Modules are non modifiable while others are. 

A Non-Contiguous Organization is when the computer is organized into various locations based   on need and Available space.

Memory segmentation
Memory segmentation is one of the ways to achieve memory protection.  In practice when a systems uses segmentation an instruction operand it refers to a memory location in which a 
value that identifies a segment and includes an offset within a segment. The segment has a set of permissions and a length associated with it.  If the process is allowed to make a type of reference to its memory and the offset of the segment is specified by the length, the reference is permitted,otherwise an hardware exception is raised.  The most common segments are Code,data and stack which was created to execute the programs on 80186 and some Microprocessors.  This isolates the programs and increases and increases the security of the memory. 



The Concept of Processor:


The concept has many different definitions but the one that is relative to the notes is the processor is an executing program.  The difference between a processor and a program is that  the program is a group of instructions while the processor is an activity. 

Process Management:   

The OS works like the computer system’s software that assists the hardware in performing process management functions. The OS keeps track of all the activate processes and allocates system resources in accordance to the policies that were devised to meet performance objectives.  In order to meet its requirements the OS must maintain many data structures as efficiently as possible.  A Processor also needs certain resources like CPU Time,memory, files and I/O devices to accomplish its tasks.  These resources are assigned to a Processor as it is created.  A single processor may also be shared amongst several processes with some scheduling algorithms that prioritize specific work within the system. 

OS are required to provide some way to create all processes needed to function.  In some systems it might be possible to have all these processes created, however in most systems processors there is a way needed to create and destroy processes during operations. 

In the OS the process management functions include Process creation,termination
of the process,Controlling the progress of the process,Process Scheduling ,Dispatching
,Interrupt handling / Exceptional handling,Switching between the processes
,Process synchronization,Interprocess communication support and Management of Process Control Blocks.

Process states:


During the lifespan of a process, its execution status may be in one of five states:  
Executing means the process that is currently running and controlling a CPU.  Waiting means that the process  can run but only when the CPU is available. Blocked means that the process is currently waiting on I/O, either for input to arrive or output to be sent. SUspended means that the process is currently able to run but for some reason it's not in the process queue.  And finally Ready means that the process is in the memory and will be executed given CPU time.

Implementation of Processes


In the implementation of the process model the OS maintains a table and an array of structures called the process table or process control block or switch frame.  Each entry identifies a process with information such as process state, its program counter,stack pointer, memory allocation and more.   

 The information storied in USB:

Process state, which might be new, ready, running, waiting or halted.
Process number, each process is identified by it’s process number, called a process ID.
Program counter, which indicates that the  address of the next instruction to be executed for this process. 
PU registers, which may vary in number and type, (depending on the concrete microprocessor architecture)
 Memory management information, which include base and bounds registers or page table.
I/O status information, composed I/O requests, I/O devices allocated to this process,
a list of open files and so on.
 


 
Processor scheduling information, which includes process priority, pointers to scheduling
queues and any other scheduling parameters within reason. 

 Threads:
Threads are independently scheduled parts of a single program. A task is only multithreaded if it  was  composed of several independent sub processes, which can work on the common data, and if each of those pieces could run in parallel. Threads simply enable us to split up a program into separate logical  pieces, and have the pieces run independently of one another, until they need to communicate with each other. 



The sharing of resources can be made more effective if the manager knows exactly what each program is going to be done in advance. The scheduling algorithm can never know this but the programmer who wrote the program does know. 

Threads allow a programmer to switch between whatever lightweight processes are best for the program. 
A process that uses threads does not get more CPU time than an ordinary process. The CPU when used does
Work on the threads. It is also  possible to write a more efficient program by making use of threads.  Inside a heavyweight process, threads are scheduled on a FCFS basis, unless the program decides to force certain threads to wait for the other threads. However 1 thread can work for 1 CPU so there might be some allocation issues. 


PROCESS SCHEDULING

Scheduling is an important operating system function. All computer resources are
scheduled before there used.  Since the  CPU is one of the primary computer resources, its scheduling is central to operating system design.  Scheduling refers to a set of policies and mechanisms supported by the operating system that controls the order in which task are completed. The main objective of scheduling is to increase CPU utilization and higher throughput.
Throughput is the amount of work completed within a given Time interval. CPU scheduling is the basis of the operating system, which supports multiprogramming by having a number of programs in computer memory at the same time  share the CPU. This mechanism improves the overall efficiency of the computer system by allowing for more work to be done in less time. 


Scheduling Objectives

The primary objective of scheduling is to improve system performance.   The secondary objectives of scheduling are as follows:




Maximize throughput

Scheduling should attempt to support and organize the largest possible number of processes per unit of time. Also Maximize the number of interactive users receiving passable  response times. 

Be predictable: No matter how pressure is put on system the given job should ultize the 
Same amount of time.

Minimize overhead: Scheduling should limit the amount of wasted resources in overhead.

Balance resource use: Scheduling should keep resources busy and allow process to use
Under utilized resources. 


Achieve a balance between response and utilization:  In order to ensure well functioning
services that have good response time and prioritize speed over resource utilization.

Enforce Priorities: Scheduling must prioritize essentially systems and processes over others.




Give preference: Prioritize important processes that hold key over others with the scheduling mechanism.

Degrade gracefully under heavy loads: A Scheduling system should not collapse under 
Heavy systems load. Instead steps should be steps to prevent the creation of new processes and ensure that if the systems comes under stress it should only see a moderate decline in quality. 

Memory overview:
??? (I honestly don’t understand what the paragraph was trying to say)


Windows disk caching:
Virtual memory is a method of using hard drive space as if it was RAM. The Virtual memory allows the operating system to run larger applications while overloading the load. The amount of Hard Drive space is dynamic so increase and decrease as needed. The Cache size will shrinks if its constantly switching data with RAM. 

 WIndows task manager:

THe WIndows task manager is used to monitor memory usage. There does seem to be a noticeable control difference between windows 11 and 10 though. 

FLash memory:
It's a type of nonvolatile memory solid state memory that holds data why the computer is shut down.  THis memory type is used in mobile dievies and USB Drives to store data. After you connect the USB Drive a letter will be assigned window and file explorer can bee used to copy data in case the laptop becomes inoperable. 

Planning the Memory Installation—Memory Features
Parity means checking for data accuracy.  NOn parity means chips that do not use any error checking.  ECC: Is an alternative to parity by using a mathematical algorithm to identify data accuracy. 

Unbuffered memory is the opposite of registered memory which is used by low to medium powered computers. IN contrast the Buffered memory that is used in high end computers.  

Memory Modecules:
Dram speed are determined by the chipset.


Based on the number of applications you typically run and the amount of physical RAM on your system, do you think your personal computer should use a larger or smaller page file?
I use an average of 3 applications on any given day. My laptop has at least 16GB of Rams so I don’t  think a larger page would be needed.
 
 
Have you ever had issues with a program using excessive amounts of memory or disk space and slowing down your computer? If so, how did you identify and solve the problem?
I’ve had trouble with my computer slowing due to excessive amounts of tabs that I had on my old computer so I tried to close them to increase its performance. 


 
 
[mrees66/tech-journal-MRees](https://www.github.com)
